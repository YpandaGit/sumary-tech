# GC 总结
## GC 分类
从GC线程运行与业务线程运行的关系可以分为三类
1. 串行收集器
是JDK1.5之前的默认算法，只有一个GC线程，在GC运行的时候，会暂停业务线程，知道GC完成
2. 并行收集器
多个GC线程并行执行，但是在GC运行时依然会暂停业务线程
3. 并发收集器
在GC线程运行时，不会暂停业务线程，适合相应要求高的应用，jdk1.8默认ConcMarkSweepGC

## 安全点 Safepoint
程序并非在所有地方都能够停顿下来开始GC，只有在到达了Safepoint之后才能暂停。而Safepoint的选定是基于`是否具有让程序长时间执行的特征`为标准进行选定的。例如方法调用、循环跳转、异常跳转。
除此之外还需要考虑如何让线程（不包括JNI调用的线程）都跑到最近的Safepoint上再停顿下来。
这里有两种方案：
1. 抢先式中断
不需要线程的执行代码主动配合，在GC发生时，首先把所有线程中断，如果发现被中断的线程不在Safepoint上就恢复线程，让它跑到Safepoint上。但如今几乎没有虚拟机采用这种方式
2. 主动式中断
当GC需要中断线程时，不直接对线程操作，仅仅简单设置一个标志，各个线程执行时主动轮询这个标志，发现中断标志为真时，就自己中断挂起。值得说明的是，轮询标志的地方和Safepoint是重合，再加上了穿件对象需要分配内存的地方。